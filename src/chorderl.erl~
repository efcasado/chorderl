%%%-------------------------------------------------------------------
%%% @author Enrique Fernandez Casado <efcasado@gmail.com>
%%% @copyright (C) 2013, Enrique Fernandez Casado
%%% @doc
%%% 
%%% @end
%%% Created : 22 Apr 2013 by Enrique Fernandez Casado <efcasado@gmail.com>
%%%-------------------------------------------------------------------
%% TODO: Improve use of gen_tcp
%% TODO: Improve error handling (what if a node disconnects?)
%% TODO: Add timeouts
-module(chorderl).

-behaviour(gen_server).

-include("../include/chorderl.hrl").

%% API
-export([create/0, join/1, start_link/1]).

%% gen_server callbacks
-export([init/1, handle_call/3, handle_cast/2, handle_info/2,
         terminate/2, code_change/3]).

%% Record representing the state of a running Chord node.
-record(state, 
        {
          me                        :: chord_node(),
          next,
          predecessor               :: chord_node(),
          fingers                   :: finger_table(),
          stabilize_interval,
          fixfingers_interval,
          checkpredecessor_interval
        }).

-define(TCP_SETTINGS, [binary, {active, false}]).


%%%===================================================================
%%% API
%%%===================================================================

%% @doc Create a new Chord ring.
create() ->
    supervisor:start_child(chorderl_sup, [create]).

%% @doc Join an existing Chord cluster.
join(BootstrapNode) ->
    supervisor:start_child(chorderl_sup, [{join, BootstrapNode}]).

%% @doc Function used by the supervisor to start a chorderl process.
start_link(Args) ->
    gen_server:start_link(?MODULE, Args).


%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Initializes the server
%%
%% @spec init(Args) -> {ok, State} |
%%                     {ok, State, Timeout} |
%%                     ignore |
%%                     {stop, Reason}
%% @end
%%--------------------------------------------------------------------
init([Mode]) ->
    io:format("[~s] Starting chorderl process~n", [?MODULE]),
    %% Read the TCP port the Chord node will be listening to.
    {ok, Port} = application:get_env(port),
    io:format("[~s] Port ( ~p )~n", [?MODULE, Port]),
    %% Read the network interface to be used from the configuration file
    {ok, NIF} = application:get_env(network_interface),
    io:format("[~s] Network interface ( ~s )~n", [?MODULE, NIF]),
    {ok, StabilizeInterval} = application:get_env(stabilize_interval),
    io:format("[~s] Stabilize interval ( ~p )~n", [?MODULE, StabilizeInterval]),
    {ok, FixFingersInterval} = application:get_env(fixfingers_interval),
    io:format("[~s] Fix fingers interval ( ~p )~n", [?MODULE, FixFingersInterval]),
    {ok, CheckPredecessorInterval} = application:get_env(checkpredecessor_interval),
    io:format("[~s] Check predecessor interval ( ~p )~n", [?MODULE, CheckPredecessorInterval]),
    case gen_tcp:listen(Port, [binary, {active, true}]) of
        {ok, ListenSocket} ->
            MyPid = self(),
            spawn(fun() -> accept_loop(MyPid, ListenSocket) end),
            Address = get_address(NIF),
            Id = chorderl_utils:sha1(Address ++ integer_to_list(Port)),
            Me = #chord_node{id = Id, address = Address, port = Port},
            erlang:send_after(StabilizeInterval, self(), stabilize),
            %erlang:send_after(FixFingersInterval, self(), fix_fingers),
            %erlang:send_after(CheckPredecessorInterval, self(), check_predecessor),
            case do_init(Mode, Me) of
                {ok, State} ->
                    {ok, State#state{next = 1,
                                     stabilize_interval = StabilizeInterval,
                                     fixfingers_interval = FixFingersInterval,
                                     checkpredecessor_interval = CheckPredecessorInterval}};
                {stop, Reason} ->
                    {stop, Reason}
            end;
        {error, Reason} ->
            {stop, Reason}
    end.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling all non call/cast messages
%%
%% @spec handle_info(Info, State) -> {noreply, State} |
%%                                   {noreply, State, Timeout} |
%%                                   {stop, Reason, State}
%% @end
%%--------------------------------------------------------------------
handle_info({tcp, Socket, Msg}, State) ->
    NewState = 
        case binary_to_term(Msg) of
            predecessor ->
                gen_tcp:send(Socket, term_to_binary({ok, State#state.predecessor})),
                State;
            {find_successor, Id} ->
                io:format("[~p] Handling 'find successor' request ( ~p )~n", [?MODULE, Id]),
                Res = find_successor(Id, State),
                io:format("[~p] Successor = ~p~n", [?MODULE, Res]),
                gen_tcp:send(Socket, term_to_binary(Res)),
                State;
            {notify, N} ->
                notify(N, State);
            _ ->
                io:format("[~p] Unsupported request received ( ~p )~n", [?MODULE, Msg])
        end,
    {noreply, NewState};
handle_info(stabilize, State) ->
    NewState = stabilize(State),
    [Succ|_] = NewState#state.fingers,
    erlang:send_after(State#state.stabilize_interval, self(), stabilize),
    {noreply, NewState};
handle_info(fix_fingers, State) ->
    io:format("[~s] fix_fingers ( ~p )~n", [?MODULE, State#state.next]),
    NewState = fix_fingers(State),
    erlang:send_after(State#state.fixfingers_interval, self(), fix_fingers),
    {noreply, NewState};
handle_info(check_predecessor, State) ->
    io:format("[~s] check_predecessor~n", [?MODULE]),
    NewState = check_predecessor(State),
    erlang:send_after(State#state.checkpredecessor_interval, self(), check_predecessor),
    {noreply, NewState};
handle_info(Msg, State) ->
    io:format("[~p] Unsupported request received ( ~p )~n", [?MODULE, Msg]),
    {noreply, State}.



%% ==============================
%% Chord protocol functions
%% ==============================

%% {ok, undefined} | {ok, chord_node()} | {error, term()}
predecessor(Succ, State) ->
    case (State#state.me =:= Succ) of
        %% If node N is its own successor, there is no need to stablish a
        %% TCP connection to retrieve its predecessor.
        true  ->
            {ok, State#state.predecessor};
        false ->
            call(Succ, predecessor)
    end.
            

%% Called periodically. Verifies the successor (S) of the node (N) and tells
%% S about N.
stabilize(State) ->
    [Succ|_] = State#state.fingers,
    NewState = case predecessor(Succ, State) of
                   {error, Reason} ->
                       State;
                   {ok, undefined} ->
                       State;
                   {ok, Pred} ->
                       PredId = chorderl_utils:id(Pred),
                       SuccId = chorderl_utils:id(Succ),
                       MyId = chorderl_utils:id(State#state.me),
                       case chorderl_utils:between(PredId, MyId, SuccId, ?RING_SIZE) of
                           true ->
                               Fs = update_finger(0, Pred, State#state.fingers),
                               State#state{fingers = Fs};
                           false ->
                               State
                       end
               end,
    case (NewState#state.me =:= Succ) of
        true  ->
            ok;
        false ->
            cast(Succ, {notify, NewState#state.me})
    end,
    NewState.

notify(Node, State) ->
    io:format("[notify@~p] ~p~n", [chorderl_utils:id(State#state.me), chorderl_utils:id(Node)]),
    case State#state.predecessor of
        undefined ->
            State#state{predecessor = Node};
        Pred ->
            PredId = list_to_integer(Pred#chord_node.id, 16),
            NodeId = list_to_integer(Node#chord_node.id, 16),
            MyId = list_to_integer((State#state.me)#chord_node.id, 16),
            case chorderl_utils:between(NodeId, PredId, MyId, ?RING_SIZE) of
                true ->
                    State#state{predecessor = Node};
                false ->
                    State
            end
    end.

fix_fingers(State) ->
    MyId = chorderl_utils:id(State#state.me),
    N = chorderl_utils:finger_pos(MyId, State#state.next),
    Next = next(State#state.next),
    NewFingers = case find_successor(N, State) of
                     {ok, NewF} ->
                         update_finger(State#state.next, NewF, State#state.fingers);
                     {error, _Reason} ->
                         State#state.fingers
                 end,
    State#state{next = Next, fingers = NewFingers}.

next(N) when N < ?M ->
    N + 1;
next(N) ->
    1.

check_predecessor(State) ->
    case State#state.predecessor of
        undefined ->
            State;
        Predecessor ->
            case call(Predecessor, ping) of
                pong ->
                    State;
                {error, _Reason} ->
                    State#state{predecessor = undefined}
            end
    end.

find_successor(Id, State) ->
    Me = State#state.me,
    MyId = list_to_integer(Me#chord_node.id, 16),
    [Succ| _] = State#state.fingers,
    case Succ of
        undefined ->
            {ok, Me};
        _ ->
            SuccId = list_to_integer(Succ#chord_node.id, 16),
            DecId = list_to_integer(Id, 16),
            case chorderl_utils:betweenr(DecId, MyId, SuccId, ?RING_SIZE) of
                true ->
                    {ok, Me};
                false ->
                    case closest_preceding_node(Id, State) of
                        {ok, CPNode} ->
                            call(CPNode, {find_successor, Id});
                        {error, _Reason} ->
                            {ok, Me}
                    end
            end
    end.

%% Searches the local finger table for the highest predecessor of the
%% specified id.
closest_preceding_node(Id, State) ->
    Me = State#state.me,
    N = list_to_integer(Me#chord_node.id, 16), 
    RFs = lists:reverse(State#state.fingers),
    do_closest_preceding_node(Id, N, RFs).

do_closest_preceding_node(Id, _N, []) ->
    {error, preceding_node_not_found};
do_closest_preceding_node(Id, N, [undefined | Fs]) ->
    do_closest_preceding_node(Id, N, Fs);
do_closest_preceding_node(Id, N, [F | Fs]) ->
    case chorderl_utils:between(F, N, Id, ?RING_SIZE) of
        true ->
            {ok, F};
        false ->
            do_closest_preceding_node(Id, N, Fs)
    end.
    

%%%===================================================================
%%% Internal functions
%%%===================================================================

update_finger(0, NewF, [_F | Fs]) ->
    [NewF | Fs];
update_finger(Nth, NewF, FingerTable) when Nth =:= length(FingerTable) ->
    lists:append(FingerTable, [NewF]);
update_finger(Nth, NewF, FingerTable) ->
    {Pre, [_ | Post]} = lists:split(Nth, FingerTable), 
    lists:append(Pre, [NewF | Post]).


call(Node, Request) when is_record(Node, chord_node) ->
    {ok, Socket} = send(Node, Request),
    R = case gen_tcp:recv(Socket, 0) of
              {ok, Res} ->
                  binary_to_term(Res);
              {error, Reason} ->
                  {error, Reason}
        end,
    ok = gen_tcp:close(Socket),
    R.

cast(Node, Msg) when is_record(Node, chord_node) ->
    {ok, Socket} = send(Node, Msg),
    ok = gen_tcp:close(Socket).

send(#chord_node{address = Address, port = Port}, Msg) ->
    %% TODO: Get the port
    {ok, Socket} = gen_tcp:connect(Address, Port, ?TCP_SETTINGS),
    gen_tcp:send(Socket, term_to_binary(Msg)),
    {ok, Socket}.

accept_loop(Parent, ListenSocket) ->
    {ok, AcceptSocket} = gen_tcp:accept(ListenSocket),
    ok = gen_tcp:controlling_process(AcceptSocket, Parent),
    accept_loop(Parent, ListenSocket).

do_init(create, Me) ->
    {ok, #state{me = Me, fingers = update_finger(0, Me, lists:map(fun(_) -> undefined end, lists:seq(1, ?M)))}};
do_init({join, BootstrapNode}, Me) ->
    [BootstrapAddress, BootstrapPort] = string:tokens(BootstrapNode, ":"),
    {ok, Address} = inet_parse:address(BootstrapAddress),
    Port = list_to_integer(BootstrapPort),
    BNode = #chord_node{address = Address, port = Port},
    case call(BNode, {find_successor, Me#chord_node.id}) of
        {error, Reason1} ->
            {stop, Reason1};
        {ok, Succ} ->
            Fs = update_finger(0, Succ, lists:map(fun(_) -> undefined end, lists:seq(1, ?M))),
            {ok, #state{me = Me, fingers = Fs}}
    end.

%% @doc Returns the IP address associated to the specified network interface.
get_address(NIF) ->
    {ok, [{addr, Addr}]} = inet:ifget(NIF, [addr]),
    inet_parse:ntoa(Addr).


%% ========================================
%% unused gen_server callbacks
%% ========================================

handle_cast(_Msg, State) ->
    {noreply, State}.

handle_call(_Request, _From, State) ->
    {noreply, State}.

terminate(_Reason, _State) ->
    ok.

code_change(_OldVsn, State, _Extra) ->
    {ok, State}.
    
